<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>听写助手</title>
  <style>
    :root{
      --bg:#0b1220;
      --muted:rgba(255,255,255,.72);
      --text:rgba(255,255,255,.92);
      --line:rgba(255,255,255,.10);
      --btn:#ffffff;
      --btnText:#0b1220;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:16px;
      --yellow:#ffd84d;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 700px at 20% 10%, #1a2b55 0%, var(--bg) 45%) fixed;
      color:var(--text);
      padding:18px;
    }
    .wrap{max-width:720px; margin:0 auto;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding:16px;
    }
    h1{
      font-size:22px;
      margin:0 0 10px;
      text-align:center;
      color:var(--yellow);
      letter-spacing:.5px;
    }
    .sub{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      margin-bottom:12px;
      text-align:center;
    }
    textarea{
      width:100%;
      height:220px;
      resize:vertical;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding:12px 12px;
      outline:none;
      font-size:16px;
      line-height:1.45;
    }
    textarea::placeholder{color:rgba(255,255,255,.45);}
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:14px;
    }
    select{
      border:none;
      outline:none;
      background: transparent;
      color: var(--text);
      font-size:14px;
      appearance:none;
      padding-right:18px;
      cursor:pointer;
    }
    .chip .arrow{
      width:0; height:0;
      border-left:5px solid transparent;
      border-right:5px solid transparent;
      border-top:6px solid rgba(255,255,255,.6);
      margin-left:-6px;
    }
    .badge{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
      height:fit-content;
    }
    button{
      width:100%;
      border:none;
      border-radius:14px;
      padding:18px 18px;
      font-size:22px;
      font-weight:800;
      cursor:pointer;
      background: var(--btn);
      color: var(--btnText);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      transition: transform .05s ease;
      margin-top:14px;
    }
    button:active{transform: translateY(1px);}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>听写助手</h1>
      <div class="sub">一行一条。每条自动读 2 遍，再停指定秒数。只有一个按钮：开始 / 暂停 / 继续。</div>

      <textarea id="input" placeholder="粘贴作业内容（每行一条）
例如：
important
take a walk
聚精会神"></textarea>

      <div class="row">
        <div class="chip" title="条与条之间停留时间">
          <span>每条停</span>
          <select id="gap">
            <option value="3" selected>3 秒</option>
            <option value="5">5 秒</option>
            <option value="8">8 秒</option>
            <option value="10">10 秒</option>
          </select>
          <span class="arrow"></span>
        </div>
        <div class="badge" id="badge">未开始</div>
      </div>

      <button id="toggle">开始</button>
    </div>
  </div>

<script>
/**
 * 终极稳定策略（微信里最稳）：
 * 1) 不复用同一个 <audio> 反复 play/pause（微信容易乱）
 * 2) 每次播放都 new Audio(url)，播完销毁
 * 3) 暂停时只“停止等待”，不主动 audio.play()
 * 4) runId 防止并发；按钮防连点 300ms
 */

let lines = [];
let idx = 0;
let paused = false;
let playing = false;

let runId = 0;
let currentAudio = null;

const elInput = document.getElementById("input");
const elGap = document.getElementById("gap");
const btn = document.getElementById("toggle");
const elBadge = document.getElementById("badge");

function setBadge(t){ elBadge.textContent = t; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function clean(text){ return text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }

// 防连点
let lastClickAt = 0;
function clickGuard(){
  const now = Date.now();
  if (now - lastClickAt < 300) return false;
  lastClickAt = now;
  return true;
}

function stopCurrentAudio(){
  try{
    if (currentAudio){
      currentAudio.pause();
      currentAudio.src = "";
      currentAudio.load?.();
      currentAudio = null;
    }
  }catch(_){}
}

async function waitUntilResumed(myRunId){
  while (paused && myRunId === runId){
    await sleep(120);
  }
}

// 暂停时不扣秒（用真实时间）
async function waitGapSeconds(myRunId){
  let remaining = Number(elGap.value) * 1000;
  let last = performance.now();

  while (remaining > 0 && myRunId === runId){
    if (paused){
      last = performance.now();
      await sleep(120);
      continue;
    }
    await sleep(80);
    const now = performance.now();
    const delta = now - last;
    last = now;
    remaining -= delta;
  }
}

async function playOnce(text, myRunId){
  if (myRunId !== runId) return;

  // 暂停的话先等
  if (paused){
    await waitUntilResumed(myRunId);
    if (myRunId !== runId) return;
  }

  const url = `/api/tts?text=${encodeURIComponent(text)}`;
  return new Promise(async (resolve, reject) => {
    if (myRunId !== runId) return resolve();

    // 每次都新建一个 Audio，微信最稳
    const a = new Audio(url);
    currentAudio = a;

    a.onended = () => {
      if (currentAudio === a) currentAudio = null;
      resolve();
    };
    a.onerror = () => {
      if (currentAudio === a) currentAudio = null;
      reject(new Error("audio error"));
    };

    try{
      await a.play();
    }catch(e){
      if (currentAudio === a) currentAudio = null;
      reject(e);
    }
  });
}

function finish(){
  playing = false;
  paused = false;
  stopCurrentAudio();
  btn.textContent = "开始";
  elInput.disabled = false;
  elGap.disabled = false;
  setBadge("完成");
}

async function loop(myRunId){
  playing = true;

  while (myRunId === runId){
    // 暂停彻底冻结
    if (paused){
      await waitUntilResumed(myRunId);
      if (myRunId !== runId) return;
    }

    // 结束判定：如果暂停中，不立刻结束，等继续后结束
    if (idx >= lines.length){
      if (paused){
        setBadge("已暂停");
        await waitUntilResumed(myRunId);
        if (myRunId !== runId) return;
      }
      break;
    }

    try{
      setBadge(paused ? "已暂停" : "进行中");

      // 每条读 2 遍
      await playOnce(lines[idx], myRunId);
      if (myRunId !== runId) return;

      if (paused){ stopCurrentAudio(); continue; }

      await playOnce(lines[idx], myRunId);
      if (myRunId !== runId) return;

      if (paused){ stopCurrentAudio(); continue; }

    }catch(e){
      console.error(e);
      setBadge("出错");
      playing = false;
      paused = false;
      stopCurrentAudio();
      btn.textContent = "开始";
      elInput.disabled = false;
      elGap.disabled = false;
      return;
    }

    // 停顿阶段：暂停不扣秒
    await waitGapSeconds(myRunId);
    if (myRunId !== runId) return;

    // 如果停顿结束那一刻你按了暂停：不推进 idx，等继续
    if (paused){
      await waitUntilResumed(myRunId);
      if (myRunId !== runId) return;
    }

    idx++;
  }

  if (myRunId === runId){
    finish();
  }
}

btn.onclick = ()=>{
  if (!clickGuard()) return;

  // 开始
  if (!playing){
    lines = clean(elInput.value);
    if (!lines.length){
      setBadge("请先粘贴内容");
      return;
    }

    idx = 0;
    paused = false;

    runId++;
    const myRunId = runId;

    elInput.disabled = true;
    elGap.disabled = true;

    btn.textContent = "暂停";
    setBadge("进行中");
    loop(myRunId);
    return;
  }

  // 暂停 / 继续
  paused = !paused;
  if (paused){
    stopCurrentAudio(); // ✅ 暂停直接停止音频（不去复用 play/pause）
    btn.textContent = "继续";
    setBadge("已暂停");
  }else{
    btn.textContent = "暂停";
    setBadge("进行中");
    // ✅ 注意：继续时不主动 play()，由 loop 自己推进，避免微信抖动
  }
};
</script>
</body>
</html>