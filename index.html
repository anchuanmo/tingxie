<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>听写助手</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1a2e;
      --muted:rgba(255,255,255,.72);
      --text:rgba(255,255,255,.92);
      --line:rgba(255,255,255,.10);
      --btn:#ffffff;
      --btnText:#0b1220;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:16px;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 700px at 20% 10%, #1a2b55 0%, var(--bg) 45%) fixed;
      color:var(--text);
      padding:18px;
    }
    .wrap{max-width:720px; margin:0 auto;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding:16px;
    }
    h1{font-size:18px; margin:0 0 6px; letter-spacing:.2px;}
    .sub{color:var(--muted); font-size:13px; line-height:1.4; margin-bottom:12px;}
    textarea{
      width:100%;
      height:190px;
      resize:vertical;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding:12px 12px;
      outline:none;
      font-size:16px;
      line-height:1.45;
    }
    textarea::placeholder{color:rgba(255,255,255,.45);}
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:14px;
    }
    select{
      border:none;
      outline:none;
      background: transparent;
      color: var(--text);
      font-size:14px;
      appearance:none;
      padding-right:18px;
      cursor:pointer;
    }
    .chip .arrow{
      width:0; height:0;
      border-left:5px solid transparent;
      border-right:5px solid transparent;
      border-top:6px solid rgba(255,255,255,.6);
      margin-left:-6px;
    }
    button{
      width:100%;
      border:none;
      border-radius:14px;
      padding:16px 18px;
      font-size:20px;
      font-weight:700;
      cursor:pointer;
      background: var(--btn);
      color: var(--btnText);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      transition: transform .05s ease;
      margin-top:12px;
    }
    button:active{transform: translateY(1px);}
    .status{
      margin-top:14px;
      padding-top:12px;
      border-top:1px solid var(--line);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .meta{color:var(--muted); font-size:13px; line-height:1.4;}
    .line{font-size:22px; font-weight:700; margin-top:4px; word-break: break-word;}
    .badge{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
      height:fit-content;
    }
    .hint{margin-top:10px; color:rgba(255,255,255,.55); font-size:12px; line-height:1.4;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>听写助手</h1>
      <div class="sub">一行一条。每条自动读 <b>2 遍</b>，再停指定秒数。只有一个按钮：开始 / 暂停 / 继续。</div>

      <textarea id="input" placeholder="粘贴作业内容（每行一条）
例如：
important
take a walk
聚精会神"></textarea>

      <div class="row">
        <div class="chip" title="条与条之间停留时间">
          <span>每条停</span>
          <select id="gap">
            <option value="3" selected>3 秒</option>
            <option value="5">5 秒</option>
            <option value="8">8 秒</option>
            <option value="10">10 秒</option>
          </select>
          <span class="arrow"></span>
        </div>
        <div class="badge" id="badge">未开始</div>
      </div>

      <button id="toggle">开始</button>

      <div class="status">
        <div>
          <div class="meta" id="status">准备就绪</div>
          <div class="line" id="line"></div>
        </div>
      </div>

      <div class="hint">提示：在微信里第一次必须点“开始”才能播放声音。</div>
    </div>
  </div>

  <audio id="audio" preload="auto"></audio>

<script>
/**
 * 这版修复点（对应你说的“暂停几次就变结束”）：
 * 1) 用 runId 防止多次点击导致多个循环并发
 * 2) 停顿计时用“真实经过时间”，暂停时不扣秒（不会偷偷走完）
 * 3) 即使最后一条已经播完，只要你按了暂停，就不会立刻显示“已结束”；
 *    必须你按“继续”，才会把最后一步走完并结束。
 */

let lines = [];
let idx = 0;
let paused = false;
let playing = false;

let runId = 0;          // 每次开始 +1，旧循环自动失效
let finishArmed = false; // 最后一条完成后，如果用户暂停，延迟结束

const elInput = document.getElementById("input");
const elGap = document.getElementById("gap");
const btn = document.getElementById("toggle");
const elStatus = document.getElementById("status");
const elLine = document.getElementById("line");
const elBadge = document.getElementById("badge");
const audio = document.getElementById("audio");

function clean(text){
  return text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function setBadge(text){ elBadge.textContent = text; }
function setStatus(text){ elStatus.textContent = text; }

function updateUI(){
  if (!lines.length || idx >= lines.length){
    elLine.textContent = "";
    return;
  }
  setBadge(paused ? "已暂停" : "进行中");
  setStatus(`第 ${idx+1} / ${lines.length} 条` + (paused ? "（暂停）" : ""));
  elLine.textContent = lines[idx];
}

async function playOnce(text, myRunId){
  const url = `/api/tts?text=${encodeURIComponent(text)}`;
  return new Promise((resolve,reject)=>{
    if (myRunId !== runId) return resolve(); // 旧任务直接结束
    audio.src = url;
    audio.onended = () => resolve();
    audio.onerror = () => reject(new Error("audio error"));
    audio.play().catch(reject);
  });
}

// 暂停等待（带 runId 保护）
async function waitUntilResumed(myRunId){
  while (paused && myRunId === runId){
    await sleep(120);
  }
}

// 停顿计时：用真实时间扣减；暂停期间不扣（不会“偷偷走完”）
async function waitGapSeconds(myRunId){
  let remaining = Number(elGap.value) * 1000;
  let last = performance.now();

  while (remaining > 0 && myRunId === runId){
    if (paused){
      // 暂停时，冻结计时，并不断刷新 last，避免恢复时瞬间扣一大段
      last = performance.now();
      await sleep(120);
      continue;
    }
    await sleep(80);
    const now = performance.now();
    const delta = now - last;
    last = now;
    // 只有在未暂停的时间段才扣减
    remaining -= delta;
  }
}

// 统一结束 UI
function finish(){
  playing = false;
  paused = false;
  finishArmed = false;
  btn.textContent = "开始";
  elInput.disabled = false;
  elGap.disabled = false;
  setBadge("完成");
  setStatus("已结束 ✅");
  elLine.textContent = "";
}

async function loop(myRunId){
  playing = true;
  finishArmed = false;

  while (myRunId === runId){
    if (idx >= lines.length){
      // 走到尽头：如果用户此刻按了暂停（常见在最后一条），不立刻结束，等他按继续
      if (paused){
        finishArmed = true;
        setBadge("已暂停");
        setStatus("最后一条已完成（暂停中）");
        await waitUntilResumed(myRunId);
        if (myRunId !== runId) return;
      }
      break;
    }

    // 暂停就彻底停住（不播、不走秒、不跳条）
    if (paused){
      await waitUntilResumed(myRunId);
      if (myRunId !== runId) return;
    }

    updateUI();

    try{
      // 每条读 2 遍
      await playOnce(lines[idx], myRunId);
      if (myRunId !== runId) return;

      if (paused){
        audio.pause();
        continue;
      }

      await playOnce(lines[idx], myRunId);
      if (myRunId !== runId) return;

      if (paused){
        audio.pause();
        continue;
      }
    }catch(e){
      setBadge("出错");
      setStatus("播放失败（网络或权限问题）");
      console.error(e);
      // 出错也别自动乱跳
      playing = false;
      btn.textContent = "开始";
      elInput.disabled = false;
      elGap.disabled = false;
      return;
    }

    // 停顿阶段：暂停时不扣秒
    await waitGapSeconds(myRunId);
    if (myRunId !== runId) return;

    // 如果停顿结束这一刻用户正好按了暂停：不推进 idx，先等继续
    if (paused){
      await waitUntilResumed(myRunId);
      if (myRunId !== runId) return;
    }

    idx++;
  }

  // 正常结束
  if (myRunId === runId){
    finish();
  }
}

btn.onclick = ()=>{
  // 开始（或重新开始）
  if (!playing){
    lines = clean(elInput.value);
    if (!lines.length){
      setBadge("等待");
      setStatus("请先粘贴内容（一行一条）");
      return;
    }
    idx = 0;
    paused = false;
    runId++;                // 新的一轮
    const myRunId = runId;

    elInput.disabled = true;
    elGap.disabled = true;  // 播放中锁住，避免误触
    btn.textContent = "暂停";
    setBadge("进行中");
    updateUI();
    loop(myRunId);
    return;
  }

  // 暂停 / 继续
  paused = !paused;
  if (paused){
    audio.pause();
    btn.textContent = "继续";
    setBadge("已暂停");
    // 如果刚好最后一条已经完成，给出更符合直觉的状态
    if (idx >= lines.length){
      setStatus("最后一条已完成（暂停中）");
    }
  }else{
    // 继续：如果之前是“最后一条完成后暂停”，此时允许结束流程继续
    audio.play().catch(()=>{});
    btn.textContent = "暂停";
    setBadge("进行中");
  }
  updateUI();
};
</script>
</body>
</html>